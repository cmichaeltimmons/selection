{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/utils.js","webpack:///./src/selection.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","eventListener","method","elements","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","element","event","capture","slice","arguments","on","off","unitify","val","unit","css","el","attr","style","entries","intersects","a","b","bxc","left","width","byc","top","height","right","bottom","Error","selectAll","selector","doc","document","nodes","length","item","push","querySelectorAll","defaultView","HTMLElement","eventPath","evt","path","composedPath","target","parentElement","removeElement","arr","index","indexOf","splice","simplifyEvent","tap","touches","x","clientX","y","clientY","abs","max","min","round","ceil","Math","preventDefault","e","DOMRect","ClientRect","Selection","that","assign","class","frame","tapMode","startThreshold","singleClick","disableTouch","selectables","scrollSpeedDivider","manualScrollSpeed","startareas","boundaries","selectionAreaContainer","_stored","_selectables","_selected","_changed","added","removed","_eventListener","beforestart","start","move","stop","_area","_areaDomRect","_clippingElement","_scrollAvailable","_scrollSpeed","_init","createElement","appendChild","classList","add","willChange","position","overflow","transform","pointerEvents","zIndex","enable","_bindStartEvents","type","_onTapStart","passive","silent","targetBoundingClientRect","getBoundingClientRect","startAreas","_boundaries","_targetContainer","find","evtpath","includes","_emit","_ax1","_ay1","_ax2","_ay2","_singleClick","clearSelection","_delayedTapMove","_onTapStop","_onSingleTap","spl","resolveSelectables","v","stored","shiftKey","reference","preceding","following","compareDocumentPosition","rangeItems","filter","select","removeFromSelection","thresholdType","_onTapMove","tb","_targetBoundary","scrollHeight","scrollWidth","_manualScroll","contains","marginTop","marginLeft","scon","ss","_recalcAreaRect","_updatedTouchingElements","_redrawArea","requestAnimationFrame","scroll","scrollY","scrollX","scrollTop","scrollLeft","deltaY","deltaX","clientHeight","clientWidth","brect","x3","y3","x4","y4","areaStyle","noevent","remove","touched","node","ok","listener","inst","area","selected","concat","changed","oe","trigger","cb","callBacks","removeAll","keepSelection","store","getSelection","cancel","keepEvent","option","undefined","disable","destroy","query","utils","version"],"mappings":"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","file":"selection.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Selection\"] = factory();\n\telse\n\t\troot[\"Selection\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/* eslint-disable prefer-rest-params */\nfunction eventListener(method, elements, events, fn, options = {}) {\n\n    // Normalize array\n    if (elements instanceof HTMLCollection || elements instanceof NodeList) {\n        elements = Array.from(elements);\n    } else if (!Array.isArray(elements)) {\n        elements = [elements];\n    }\n\n    if (!Array.isArray(events)) {\n        events = [events];\n    }\n\n    for (const element of elements) {\n        for (const event of events) {\n            element[method](event, fn, {capture: false, ...options});\n        }\n    }\n\n    return Array.prototype.slice.call(arguments, 1);\n}\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener.bind(null, 'addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener.bind(null, 'removeEventListener');\n\nconst unitify = (val, unit = 'px') => typeof val === 'number' ? val + unit : val;\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or a object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(el, attr, val) {\n    const style = el && el.style;\n    if (style) {\n        if (typeof attr === 'object') {\n\n            for (const [key, value] of Object.entries(attr)) {\n                style[key] = unitify(value);\n            }\n\n        } else if (val && typeof attr === 'string') {\n            style[attr] = unitify(val);\n        }\n    }\n}\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a, b, mode) {\n    switch (mode || 'touch') {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n        default: {\n            throw new Error(`Unkown intersection mode: ${mode}`);\n        }\n    }\n}\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector, doc = document) {\n    if (!Array.isArray(selector)) {\n        selector = [selector];\n    }\n\n    const nodes = [];\n    for (let i = 0, l = selector.length; i < l; i++) {\n        const item = selector[i];\n\n        if (typeof item === 'string') {\n            nodes.push(...doc.querySelectorAll(item));\n        } else if (item instanceof doc.defaultView.HTMLElement) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n\n/**\n * Polyfill for safari & firefox for the eventPath event property.\n * @param evt The event object.\n * @return [String] event path.\n */\nexport function eventPath(evt) {\n    let path = evt.path || (evt.composedPath && evt.composedPath());\n\n    if (path && path.length > 0) {\n        return path;\n    }\n\n    let el = evt.target;\n    for (path = [el]; (el = el.parentElement);) {\n        path.push(el);\n    }\n\n    path.push(document, window);\n    return path;\n}\n\n/**\n * Removes an element from an Array.\n */\nexport function removeElement(arr, el) {\n    const index = arr.indexOf(el);\n\n    if (~index) {\n        arr.splice(index, 1);\n    }\n}\n\nexport function simplifyEvent(evt) {\n    const tap = (evt.touches && evt.touches[0] || evt);\n    return {\n        tap,\n        x: tap.clientX,\n        y: tap.clientY,\n        target: tap.target\n    };\n}\n","import {css, eventPath, intersects, off, on, removeElement, selectAll, simplifyEvent} from './utils';\nimport {version} from '../package';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, round, ceil} = Math;\nconst preventDefault = e => e.preventDefault();\n\n// Edge < 79 uses the unofficial name ClienRect\nconst DOMRect = typeof window.DOMRect === 'undefined' ? window.ClientRect : window.DOMRect;\n\n/* eslint-disable new-cap */\nfunction Selection(options = {}) {\n\n    const that = {\n\n        options: Object.assign({\n            class: 'selection-area',\n            frame: document,\n            mode: 'touch',\n            tapMode: 'native',\n            startThreshold: 10,\n            singleClick: true,\n            disableTouch: false,\n\n            selectables: [],\n            scrollSpeedDivider: 10,\n            manualScrollSpeed: 750,\n\n            startareas: ['html'],\n            boundaries: ['html'],\n            selectionAreaContainer: 'body'\n        }, options),\n\n        // Store for keepSelection\n        _stored: [],\n        _selectables: [],\n        _selected: [], // Currently touched elements\n        _changed: {\n            added: [], // Added elements since last selection\n            removed: [] // Removed elements since last selection\n        },\n\n        // Evenlistener name: [callbacks]\n        _eventListener: {\n            beforestart: [],\n            start: [],\n            move: [],\n            stop: []\n        },\n\n        // Create area element\n        _area: null,\n        _areaDomRect: null, // Caches the position of the selection-area\n        _clippingElement: null,\n\n        // Is getting set on movement. Varied.\n        _scrollAvailable: true,\n        _scrollSpeed: {x: null, y: null},\n\n        _init() {\n            const {frame} = that.options;\n            that._area = frame.createElement('div');\n            that._clippingElement = frame.createElement('div');\n            that._clippingElement.appendChild(that._area);\n\n            // Add class to the area element\n            that._area.classList.add(that.options.class);\n\n            // Apply basic styles to the area element\n            css(that._area, {\n                willChange: 'top, left, bottom, right, width, height',\n                top: 0,\n                left: 0,\n                position: 'fixed'\n            });\n\n            css(that._clippingElement, {\n                overflow: 'hidden',\n                position: 'fixed',\n                transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n                pointerEvents: 'none',\n                zIndex: '1'\n            });\n\n            that.enable();\n        },\n\n        _bindStartEvents(type) {\n            const {frame} = that.options;\n            const fn = type === 'on' ? on : off;\n            fn(frame, 'mousedown', that._onTapStart);\n\n            if (!that.options.disableTouch) {\n                fn(frame, 'touchstart', that._onTapStart, {\n                    passive: false\n                });\n            }\n        },\n\n        _onTapStart(evt, silent = false) {\n            const {x, y, target} = simplifyEvent(evt);\n            const {startareas, boundaries, frame} = that.options;\n            const targetBoundingClientRect = target.getBoundingClientRect();\n\n            // Find start-areas and boundaries\n            const startAreas = selectAll(startareas, frame);\n            that._boundaries = selectAll(boundaries, frame);\n\n            // Check in which container the user currently acts\n            that._targetContainer = that._boundaries.find(el =>\n                intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n            );\n\n            // Check if area starts in one of the start areas / boundaries\n            const evtpath = eventPath(evt);\n            if (!that._targetContainer ||\n                !startAreas.find(el => evtpath.includes(el)) ||\n                !that._boundaries.find(el => evtpath.includes(el))) {\n                return;\n            }\n\n            if (!silent && that._emit('beforestart', evt) === false) {\n                return;\n            }\n\n            // Area start point\n            that._ax1 = x;\n            that._ay1 = y;\n\n            // Area end point\n            that._ax2 = 0;\n            that._ay2 = 0;\n\n            // To detect single-click\n            that._singleClick = true;\n            that.clearSelection(false);\n\n            // Prevent default select event\n            on(frame, 'selectstart', preventDefault);\n\n            // Add listener\n            on(frame, ['touchmove', 'mousemove'], that._delayedTapMove, {passive: false});\n            on(frame, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\n\n            // Firefox will scroll down the page which would break the selection.\n            evt.preventDefault();\n        },\n\n        _onSingleTap(evt) {\n            const {tapMode} = that.options;\n            const spl = simplifyEvent(evt);\n            let target = null;\n\n            if (tapMode === 'native') {\n                target = spl.target;\n            } else if (tapMode === 'touch') {\n                that.resolveSelectables();\n\n                const {x, y} = spl;\n                target = that._selectables.find(v => {\n                    const {right, left, top, bottom} = v.getBoundingClientRect();\n                    return x < right && x > left && y < bottom && y > top;\n                });\n            } else {\n                throw new Error(`Unknown tapMode option: ${tapMode}`);\n            }\n\n            if (!target) {\n                return false;\n            }\n\n            /**\n             * Resolve selectables again.\n             * If the user starded in a scrollable area they will be reduced\n             * to the current area. Prevent the exclusion of these if a range-selection\n             * gets performed.\n             */\n            that.resolveSelectables();\n\n            // Traverse dom upwards to check if target is selectable\n            while (!that._selectables.includes(target)) {\n                if (!target.parentElement) {\n                    return;\n                }\n\n                target = target.parentElement;\n            }\n\n            that._emit('start', evt);\n            const stored = that._stored;\n            if (evt.shiftKey && stored.length) {\n                const reference = stored[stored.length - 1];\n\n                // Resolve correct range\n                const [preceding, following] = reference.compareDocumentPosition(target) & 4 ? [target, reference] : [reference, target];\n\n                const rangeItems = [...that._selectables.filter(el =>\n                    (el.compareDocumentPosition(preceding) & 4) &&\n                    (el.compareDocumentPosition(following) & 2)\n                ), target];\n\n                that.select(rangeItems);\n                that._emit('move', evt);\n                that._emit('stop', evt);\n            } else {\n\n                if (that._stored.includes(target)) {\n                    that.removeFromSelection(target);\n                } else {\n                    that.select(target);\n                }\n\n                that._emit('move', evt);\n                that._emit('stop', evt);\n            }\n        },\n\n        _delayedTapMove(evt) {\n            const {x, y} = simplifyEvent(evt);\n            const {startThreshold, frame} = that.options;\n            const {_ax1, _ay1} = that; // Coordinates of first \"tap\"\n\n            // Check pixel threshold\n            const thresholdType = typeof startThreshold;\n            if ((thresholdType === 'number' && abs((x + y) - (_ax1 + _ay1)) >= startThreshold) ||\n                (thresholdType === 'object' && abs(x - _ax1) >= startThreshold.x || abs(y - _ay1) >= startThreshold.y)) {\n                off(frame, ['mousemove', 'touchmove'], that._delayedTapMove, {passive: false});\n                on(frame, ['mousemove', 'touchmove'], that._onTapMove, {passive: false});\n\n                // Make area element visible\n                css(that._area, 'display', 'block');\n\n                // Apppend selection-area to the dom\n                selectAll(that.options.selectionAreaContainer, frame)[0].appendChild(that._clippingElement);\n\n                // Now after the threshold is reached resolve all selectables\n                that.resolveSelectables();\n\n                // An action is recognized as single-select until the user performed a mutli-selection\n                that._singleClick = false;\n\n                // Just saving the boundaries of this container for later\n                const tb = that._targetBoundary = that._targetContainer.getBoundingClientRect();\n\n                // Find container and check if it's scrollable\n                if (round(that._targetContainer.scrollHeight) !== round(tb.height) ||\n                    round(that._targetContainer.scrollWidth) !== round(tb.width)) {\n\n                    // Indenticates if the user is currently in a scrollable area\n                    that._scrollAvailable = true;\n\n                    // Detect mouse scrolling\n                    on(window, 'wheel', that._manualScroll, {passive: false});\n\n                    /**\n                     * The selection-area will also cover other element which are\n                     * out of the current scrollable parent. So find all elements\n                     * which are in the current scrollable element. Later these are\n                     * the only selectables instead of all.\n                     */\n                    that._selectables = that._selectables.filter(s => that._targetContainer.contains(s));\n\n                    /**\n                     * To clip the area, the selection area has a parent\n                     * which has exact the same dimensions as the scrollable elemeent.\n                     * Now if the area exeeds these boundaries it will be cropped.\n                     */\n                    css(that._clippingElement, {\n                        top: tb.top,\n                        left: tb.left,\n                        width: tb.width,\n                        height: tb.height\n                    });\n\n                    /**\n                     * The area element is relative to the clipping element,\n                     * but when this is moved or transformed we need to correct\n                     * the positions via a negative margin.\n                     */\n                    css(that._area, {\n                        marginTop: -tb.top,\n                        marginLeft: -tb.left\n                    });\n                } else {\n                    that._scrollAvailable = false;\n\n                    /**\n                     * Reset margin and clipping element dimensions.\n                     */\n                    css(that._clippingElement, {\n                        top: 0,\n                        left: 0,\n                        width: '100%',\n                        height: '100%'\n                    });\n\n                    css(that._area, {\n                        marginTop: 0,\n                        marginLeft: 0\n                    });\n                }\n\n                // Trigger recalc and fire event\n                that._onTapMove(evt);\n                that._emit('start', evt);\n            }\n\n            evt.preventDefault(); // Prevent swipe-down refresh\n        },\n\n        _onTapMove(evt) {\n            const {x, y} = simplifyEvent(evt);\n            const {scrollSpeedDivider} = that.options;\n            const scon = that._targetContainer;\n            let ss = that._scrollSpeed;\n            that._ax2 = x;\n            that._ay2 = y;\n\n            if (that._scrollAvailable && (ss.y !== null || ss.x !== null)) {\n\n                // Continous scrolling\n                requestAnimationFrame(function scroll() {\n\n                    // Make sure that ss is not outdated\n                    ss = that._scrollSpeed;\n                    const scrollY = ss.y !== null;\n                    const scrollX = ss.x !== null;\n\n                    // Scrolling is not anymore required\n                    if (!scrollY && !scrollX) {\n                        return;\n                    }\n\n                    /**\n                     * If the value exeeds the scrollable area it will\n                     * be set to the max / min value. So change only\n                     */\n                    const {scrollTop, scrollLeft} = scon;\n\n                    // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                    if (scrollY) {\n                        scon.scrollTop += ceil(ss.y / scrollSpeedDivider);\n                        that._ay1 -= scon.scrollTop - scrollTop;\n                    }\n\n                    if (scrollX) {\n                        scon.scrollLeft += ceil(ss.x / scrollSpeedDivider);\n                        that._ax1 -= scon.scrollLeft - scrollLeft;\n                    }\n\n                    /**\n                     * We changed the start coordinates -> redraw the selectiona area\n                     * We changed the dimensions of the area element -> re-calc selected elements\n                     * The selected elements array has been changed -> fire event\n                     */\n                    that._recalcAreaRect();\n                    that._updatedTouchingElements();\n                    that._emit('move', evt);\n                    that._redrawArea();\n\n                    // Keep scrolling even if the user stops to move his pointer\n                    requestAnimationFrame(scroll);\n                });\n            } else {\n\n                /**\n                 * Perform redraw only if scrolling is not active.\n                 * If scrolling is active this area is getting re-dragwed by the\n                 * anonymized scroll function.\n                 */\n                that._recalcAreaRect();\n                that._updatedTouchingElements();\n                that._emit('move', evt);\n                that._redrawArea();\n            }\n\n            evt.preventDefault(); // Prevent swipe-down refresh\n        },\n\n        _manualScroll(evt) {\n            const {manualScrollSpeed} = that.options;\n\n            // Consistent scrolling speed on all browsers\n            const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n            const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n            that._scrollSpeed.y += deltaY * manualScrollSpeed;\n            that._scrollSpeed.x += deltaX * manualScrollSpeed;\n            that._onTapMove(evt);\n\n            // Prevent defaul scrolling behaviour, eg. page scrolling\n            evt.preventDefault();\n        },\n\n        _recalcAreaRect() {\n            const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = that._targetContainer;\n            const brect = that._targetBoundary;\n            const ss = that._scrollSpeed;\n            let x = that._ax2;\n            let y = that._ay2;\n\n            if (x < brect.left) {\n                ss.x = scrollLeft ? -abs(brect.left - x) : null;\n                x = brect.left;\n            } else if (x > brect.left + brect.width) {\n                ss.x = scrollWidth - scrollLeft - clientWidth ? abs(brect.left + brect.width - x) : null;\n                x = brect.left + brect.width;\n            } else {\n                ss.x = null;\n            }\n\n            if (y < brect.top) {\n                ss.y = scrollTop ? -abs(brect.top - y) : null;\n                y = brect.top;\n            } else if (y > brect.top + brect.height) {\n                ss.y = scrollHeight - scrollTop - clientHeight ? abs(brect.top + brect.height - y) : null;\n                y = brect.top + brect.height;\n            } else {\n                ss.y = null;\n            }\n\n            const x3 = min(that._ax1, x);\n            const y3 = min(that._ay1, y);\n            const x4 = max(that._ax1, x);\n            const y4 = max(that._ay1, y);\n            that._areaDomRect = new DOMRect(x3, y3, x4 - x3, y4 - y3);\n        },\n\n        _redrawArea() {\n            const {x, y, width, height} = that._areaDomRect;\n            const areaStyle = that._area.style;\n\n            // It's generally faster to not use es6-templates\n            // It's also faster to manually change the properties instead of calling Object.assign\n            /* eslint prefer-template: \"off\" */\n            areaStyle.transform = 'translate3d(' + x + 'px,' + y + 'px, 0)';\n            areaStyle.width = width + 'px';\n            areaStyle.height = height + 'px';\n        },\n\n        _onTapStop(evt, noevent) {\n            const {frame, singleClick} = that.options;\n\n            // Remove event handlers\n            off(frame, ['mousemove', 'touchmove'], that._delayedTapMove);\n            off(frame, ['touchmove', 'mousemove'], that._onTapMove);\n            off(frame, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\n\n            if (evt && that._singleClick && singleClick) {\n                that._onSingleTap(evt);\n            } else if (!that._singleClick && !noevent) {\n                that._updatedTouchingElements();\n                that._emit('stop', evt);\n            }\n\n            // Reset scroll speed\n            that._scrollSpeed = {x: null, y: null};\n\n            // Unbind mouse scrolling listener\n            off(window, 'wheel', that._manualScroll);\n\n            // Remove selection-area from dom\n            that._clippingElement.remove();\n\n            // Enable default select event\n            off(frame, 'selectstart', preventDefault);\n            css(that._area, 'display', 'none');\n        },\n\n        _updatedTouchingElements() {\n            const {_selected, _selectables, options, _areaDomRect} = that;\n            const {mode} = options;\n\n            // Update\n            const touched = [];\n            const added = [];\n            const removed = [];\n\n            // Itreate over the selectable elements\n            for (let i = 0; i < _selectables.length; i++) {\n                const node = _selectables[i];\n\n                // Check if area intersects element\n                if (intersects(_areaDomRect, node.getBoundingClientRect(), mode)) {\n\n                    // Check if the element wasn't present in the last selection.\n                    if (!_selected.includes(node)) {\n                        added.push(node);\n                    }\n\n                    touched.push(node);\n                }\n            }\n\n            // Check which elements where removed since last selection\n            for (let i = 0; i < _selected.length; i++) {\n                const el = _selected[i];\n                if (!touched.includes(el)) {\n                    removed.push(el);\n                }\n            }\n\n            // Save\n            that._selected = touched;\n            that._changed = {added, removed};\n        },\n\n        _emit(event, evt) {\n            let ok = true;\n\n            for (const listener of that._eventListener[event]) {\n                ok = listener.call(that, {\n                    inst: that,\n                    area: that._area,\n                    selected: that._selected.concat(that._stored),\n                    changed: that._changed,\n                    oe: evt\n                }) && ok;\n            }\n\n            return ok;\n        },\n\n        /**\n         * Manually triggers the start of a selection\n         * @param evt A MouseEvent / TouchEvent -like object\n         * @param silent If beforestart should be fired,\n         */\n        trigger(evt, silent = true) {\n            that._onTapStart(evt, silent);\n        },\n\n        /**\n         * Adds an eventlistener\n         * @param event\n         * @param cb\n         */\n        on(event, cb) {\n            that._eventListener[event].push(cb);\n            return that;\n        },\n\n        /**\n         * Removes an event listener\n         * @param event\n         * @param cb\n         */\n        off(event, cb) {\n            const callBacks = that._eventListener[event];\n\n            if (callBacks) {\n                const index = callBacks.indexOf(cb);\n\n                if (~index) {\n                    callBacks.splice(index, 1);\n                }\n            }\n\n            return that;\n        },\n\n        /**\n         * Removes all event listeners for event\n         * @param event\n         * @param cb\n         */\n        removeAll(event) {\n            that._eventListener[event] = [];\n            return that;\n        },\n\n        /**\n         * Can be used if during a selection elements have been added.\n         * Will update everything which can be selected.\n         */\n        resolveSelectables() {\n\n            // Resolve selectors\n            that._selectables = selectAll(that.options.selectables, that.options.frame);\n        },\n\n        /**\n         * Saves the current selection for the next selecion.\n         * Allows multiple selections.\n         */\n        keepSelection() {\n            const {_selected, _stored} = that;\n\n            for (let i = 0; i < _selected.length; i++) {\n                const el = _selected[i];\n                if (!_stored.includes(el)) {\n                    _stored.push(el);\n                }\n            }\n        },\n\n        /**\n         * Clear the elements which where saved by 'keepSelection()'.\n         * @param store If the store should also get cleared\n         */\n        clearSelection(store = true) {\n            store && (that._stored = []);\n            that._selected = [];\n            that._changed.added = [];\n            that._changed.removed = [];\n        },\n\n        /**\n         * Removes an particular element from the selection.\n         */\n        removeFromSelection(el) {\n            that._changed.removed.push(el);\n            removeElement(that._stored, el);\n            removeElement(that._selected, el);\n        },\n\n        /**\n         * @returns {Array} Selected elements\n         */\n        getSelection() {\n            return that._stored;\n        },\n\n        /**\n         * Cancel the current selection process.\n         * @param keepEvent {boolean} true to fire the onStop listener after cancel.\n         */\n        cancel(keepEvent = false) {\n            that._onTapStop(null, !keepEvent);\n        },\n\n        /**\n         * Set or get an option.\n         * @param   {string} name\n         * @param   {*}      value\n         * @return  {*}      the new value\n         */\n        option(name, value) {\n            const {options} = that;\n            return value === undefined ? options[name] : (options[name] = value);\n        },\n\n        /**\n         * Disable the selection functinality.\n         */\n        disable() {\n            that._bindStartEvents('off');\n        },\n\n        /**\n         * Unbinds all events and removes the area-element\n         */\n        destroy() {\n            that.disable();\n            that._clippingElement.remove();\n        },\n\n        /**\n         * Disable the selection functinality.\n         */\n        enable() {\n            that._bindStartEvents('on');\n        },\n\n        /**\n         * Manually select elements\n         * @param query - CSS Query, can be an array of queries\n         */\n        select(query) {\n            const {_selected, _stored, options} = that;\n            const elements = selectAll(query, options.frame).filter(el =>\n                !_selected.includes(el) &&\n                !_stored.includes(el)\n            );\n\n            that._selected.push(...elements);\n            that._changed.added.push(...elements);\n            return elements;\n        }\n    };\n\n    // Initialize\n    that._init();\n\n    return that;\n}\n\n// Export utils\nSelection.utils = {\n    on,\n    off,\n    css,\n    intersects,\n    selectAll,\n    eventPath,\n    removeElement\n};\n\n/**\n * Create selection instance\n * @param {Object} [options]\n */\nSelection.create = options => Selection(options);\n\n// Set version and export\nSelection.version = version;\nexport default Selection;\n"],"sourceRoot":""}